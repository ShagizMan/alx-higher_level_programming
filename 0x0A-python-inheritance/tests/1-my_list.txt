# 1-my_list.txt

========================
How to use 1-my_list.txt
========================

This module defines a class ``MyList`` from ``list``.

Instantiation
=============

``MyList`` can be instantiated with no argument which will return an empty list.
::

	>>> MyList = __import__('1-my_list').MyList
	>>> my_list = MyList()
	>>> type(my_list)
	<class '1-my_list.MyList'>

::

	>>> print(my_list)
	[]

Or a single argument, which must be an iteraterable object.
::

	>>> my_list = MyList([1, 2, 3])
	>>> print(my_list)
	[1, 2, 3]

A ``TypeError`` will be raised for any more than one instantiation arguments.
::

	>>> my_list = MyList([1, 2], [3, 4])
	Traceback (most recent call last):
        TypeError: The list must have only one argument.

Usage
=====
``MyList`` is an inherited ``list`` class, and thus features the same method.
::

	>>> my_list = MyList()
	>>> my_list.append(1)
	>>> my_list.append(2)
	>>> my_list.append(3)
	>>> print(my_list)
	[1, 2, 3]

Replace with indexing.
::

	>>> my_list[0] = 5
	>>> print(my_list)
	>>> [5, 2, 3]

And removed with the ``remove()`` method.
::

	>>> my_list.remove(5)
	>>> print(my_list)
	[2, 3]

See the documentation on Python lists for more built-in methods.
``print_sorted`` Method
=======================
::

    >>> my_list.print_sorted(1)
    Traceback (most recent call last):
    TypeError: print_sorted() takes 1 positional argument but 2 were given

::

    >>> my_list.print_sorted()
    [1, 2, 3, 4, 5]

The order of the original list is not altered after a call to the method.
::

    >>> print(my_list)
    [1, 4, 2, 3, 5]

If ``print_sorted(...)`` is called on a list of different types, a TypeError
will be raised.
::

    >>> my_list = MyList([1, "Betty", "Holberton", 5])
    >>> my_list.print_sorted()
    Traceback (most recent call last):
    TypeError: unorderable types: str() < int()
